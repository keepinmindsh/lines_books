# 03 저장소와 검색 

> 항상 주변을 단정히 정돈하는 사람은 단지 찾기를 너무 귀찮아 하는 사람이다.   
>  - 독일 속담

- 트랜잭션 작업 부하에 맞춰 최적화된 저장소 엔진과 분석을 위해 최적화된 엔진 간에는 큰 차이가 있다! 
- 데이터 베이스에서 특정 키의 값을 효율적으로 찾기 위해서는 다른 데이터 구조가 필요하다. 바로 **색인**이다.
  - 색인의 일반적인 개념은 어떤 부가적인 메타데이터를 유지하는 것이다! 

## 색인 

### 해시색인  

- 키/값 데이터 
- 사전 타입 ( Dictionary Type )
- 해시 맵을 전부 메모리에 유지하기 때문에 사용 가능한 램에 모두 저장된다는 조건을 전제로 고성능으로 읽기, 쓰기를 보장한다. 

- 항상 파일이 추가될 때 디스크 공간만 부족해지는데, 
  - 특정 크기의 세그먼트로 로그를 나누는 방식이 해결책이다. 
  - 특정 크기에 도달하면 세그먼트 파일을 닫고 새로운 세그먼트 파일에 이후 쓰기를 수행한다. 

- 추가 로그 전용 설계의 장,단점 
  - 장점
    - 추가와 세그먼트 병합은 순차적인 쓰기 작업이기 때문에 보통 무작위 쓰기보다 훨씬 빠르다. 특히 자기 회전 디스크 하드 드라이브에서 그렇다. 일부 확장된 순차쓰기는 Solid State Drive 도 선호한다. 
    - 세그먼트 파일이 추가 전용이나 불변이면 동시성과 고장복구는 훨씬 간단하다. 예를 들어 값을 덮어 쓰는 동안 데이터베이스가 죽는 경우에 대해서 걱정할 필요가 없다. 이전 값 부분과 새로운 값 부분을 포함한 파일을 나누어 함께 남겨두기 때문이다. 
    - 오래된 세그먼트 병합은 시간이 지남에 따라 조각호되는 데이터 파일 문제를 피할 수 있다. 
  - 단점 
    - 해시테이블은 메모리에 저장해야하므로 키가 너무 많으면 문제가 된다. 디스크 상의 해시 맵에 좋은 성능을 기대하기 어렵다. 
    - 해시테이블은 질의 범위에 효율적이지 않다. 예를 들어 kitty00000 ~ kitty99999 사이의 모든 키를 쉽게 스캔 할 수 없다. 

### SS 테이블과 LSM 트리 

- SS 테이블 
  - 키 - 값 쌍을 키로 정렬하는 것 
  - 정렬된 형식을 정렬된 문자열 테이블 ( Sorted String Table ) 또는 짧게 SS Table 이라고 한다. 그리고 또한 각 키는 각 병합된 세그먼트 파일 내에 한번만 나타나야 한다. 
    - 세그먼트 병합은 파일이 사용된 메모리보다 크더라도 간단하고 효율적이다.
    - 파일에서 특정 키를 찾기 위해 더는 메모리에 모든 키의 색인을 유지할 수 없다. 
    - 읽기 요청은 요청 범위 내에서 여러 키-값 쌍을 스캔해야 하기 때문에 해당 레코드들을 블록으로 그룹화하고 디스크에 쓰기전에 압축한다. 

- SS 테이블 생성과 유지 
  - 디스크 상에 정렬된 구조를 유지하는 일은 가능하지만 메모리에 유지하는 편이 훨씬 쉽다. 
  - 레드 블랙 트리 ( Red-Black Tree) 나 AVL 트리와 같이 잘 알려져 있고 사용가능한 트리 구조는 많이 있다. 
  - 저장소 엔진 
    - 쓰기가 들어오면 인 메모리 균형 트리 데이터 구조에 추가한다. 
    - 멤 테이블이 보통 수 메가 바이트 정도의 임계값보다 커지만 SS 테이블 파일로 디스크에 기록한다. 
    - 읽기 요청을 제공하려면 먼저 멤 테이블에서 키를 찾아야 한다. 
    - 가끔 세그먼트 파일을 함치고 덮어 삭제된 값을 버리는 병합과 컴팩션 과정을 수행한다. 
